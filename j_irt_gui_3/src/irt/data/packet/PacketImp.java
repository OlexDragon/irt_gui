/*
 * IRT Management Protocol Specification.docx
 * 
 * 3. Application Layer
 * 3.1 Packet structure
 * Serial line protocol management packet consists of header and one or multiple parameters. 
 */
package irt.data.packet;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import irt.data.PacketThread;
import irt.data.ToHex;
import irt.data.packet.interfaces.Packet;

public class PacketImp implements Packet{

	public static final byte FLAG_SEQUENCE	= 0x7E;
	public static final byte CONTROL_ESCAPE= 0x7D;

	/* 3.2 Packet header 
	 * Packet header includes the following fields:
	 */
	public static final byte
		PACKET_TYPE_SPONTANEOUS		= 0x0,			/* Spontaneous message, generated by device. */
		PACKET_TYPE_RESPONSE		= 0x1,			/* Response, generated as response to command or status request. */
		PACKET_TYPE_REQUEST			= 0x2,			/* Status request. */
		PACKET_TYPE_COMMAND			= 0x3,			/* Command. */
		PACKET_TYPE_ACKNOWLEDGEMENT	= (byte) 0xFF;	/* Layer 2 acknowledgement. */

	/* Parameter general types definition. */
	public static final byte
		PARAMETER_NONE		= 0,
		PARAMETER_ALL		= (byte) 255;

	/* Measurement codes. */
	public static final byte
			PARAMETER_MEASUREMENT_INPUT_POWER	= 1,
			PARAMETER_MEASUREMENT_OUTPUT_POWER	= 2,
			PARAMETER_MEASUREMENT_STATUS		= 4,
			PARAMETER_MEASUREMENT_WGS_POSITION	= 4,
			PARAMETER_MEASUREMENT_LNB1_STATUS	= 5,
			PARAMETER_MEASUREMENT_LNB2_STATUS	= 6,
			IRT_SLCP_PARAMETER_MEASUREMENT_PICOBUC_ALL = PARAMETER_ALL; /* Read all available measurements. */

	public static final byte
		PARAMETER_MEASUREMENT_FCM_NONE = PARAMETER_NONE,
		PARAMETER_MEASUREMENT_FCM_SUMMARY_ALARM		= 1,	//Flags
		PARAMETER_MEASUREMENT_FCM_STATUS			= 2,
		PARAMETER_MEASUREMENT_TEMPERATURE			= 3,
		PARAMETER_MEASUREMENT_FCM_INPUT_POWER		= 4,
		PARAMETER_MEASUREMENT_FCM_OUTPUT_POWER		= 5,
		PARAMETER_MEASUREMENT_FCM_MON_5V5			= 6,
		PARAMETER_MEASUREMENT_FCM_MON_13V2_POS		= 7,
		PARAMETER_MEASUREMENT_FCM_MON_13V2_NEG		= 8,
		PARAMETER_MEASUREMENT_FCM_CURRENT			= 9,
		PARAMETER_MEASUREMENT_FCM_TEMPERATURE_CPU	= 10,
		PARAMETER_MEASUREMENT_FCM_ALL = PARAMETER_ALL;	/* Read all available measurements. */

	/*Device Debug - IRT_SLCP_PACKET_ID_DEVICE_DEBUG*/
	public static final byte
	PARAMETER_DEVICE_DEBUG_INFO 		= 1,		/* device information: parts, firmware and etc. */
	PARAMETER_DEVICE_DEBUG_DUMP 		= 2,		/* dump of registers for specified device index */
	PARAMETER_DEVICE_DEBUG_READ_WRITE 	= 3,		/* registers read/write operations */
	PARAMETER_DEVICE_DEBUG_INDEX 		= 4,		/* device index information print */
	PARAMETER_DEVICE_DEBUG_CALIBRATION_MODE = 5,	/* calibration mode */
	PARAMETER_DEVICE_DEBUG_ENVIRONMENT_IO = 10,	/* operations with environment variables */
	PARAMETER_DEVICE_DEBUG_DEVICES		= 30;		

	/* Configuration codes. */
	public static final byte
		PARAMETER_CONFIG_FCM_NONE = (PARAMETER_NONE),
		PARAMETER_CONFIG_FCM_GAIN										= 1,
		PARAMETER_CONFIG_FCM_ATTENUATION								= 2,
		PARAMETER_CONFIG_FCM_FREQUENCY									= 3,
		PARAMETER_CONFIG_FCM_FREQUENCY_RANGE							= 4,
		PARAMETER_CONFIG_ATTENUATION_RANGE								= 6,
		PARAMETER_CONFIG_FCM_MUTE_CONTROL								= 7,
		PARAMETER_CONFIG_LNB_POWER										= 8,
		PARAMETER_CONFIG_FCM_FLAGS 										= 9,
		PARAMETER_CONFIG_FCM_GAIN_OFFSET								= 10,
		PARAMETER_CONFIG_FCM_ALC_ENABLED								= 12,
		PARAMETER_CONFIG_FCM_ALC_LEVEL									= 13,
		PARAMETER_CONFIG_FCM_ALC_RANGE									= 14,
		PARAMETER_CONFIG_DLRS_WGS_SWITCHOVER							= 14,
		PARAMETER_CONFIG_FCM_ALC_OVERDRIVE_PROTECTION_ENABLED			= 15,
		PARAMETER_CONFIG_FCM_ALC_OVERDRIVE_PROTECTION_THRESHOLD			= 16,
		PARAMETER_CONFIG_FCM_ALC_OVERDRIVE_PROTECTION_THRESHOLD_RANGE	= 17,
		PARAMETER_CONFIG_FCM_LNB_REFERENCE_CONTROL						= 21,
		PARAMETER_CONFIG_BUC_APC_ENABLE                					= 110,     /* APC enable */
		PARAMETER_CONFIG_BUC_OFFSET_RANGE	         					= 103,    
		PARAMETER_CONFIG_BUC_OFFSET_1_TO_MULTI         					= 104,    
		PARAMETER_CONFIG_BUC_APC_LEVEL		          					= 111,     /* APC target power level */
		PARAMETER_CONFIG_BUC_APC_RANGE        		  					= 112,     /* APC target power range */
		PARAMETER_CONFIG_LNB_LO_SELECT                					= 124, 
		PARAMETER_CONFIG_LNB_STATUST                					= 125, 

		PARAMETER_CONFIG_FCM_ALL = PARAMETER_ALL;		/* Read all available parameters. */

	/* Test. */
	public static final byte
		IRT_SLCP_PARAMETER_DEVELOPER_GENERIC_SET_1_DAC_CONFIG = 1;

	public static final byte
	PARAMETER_PRODUCTION_GENERIC_SET_1_CALIBRATION_MODE_CONFIG = 1,
	PARAMETER_PRODUCTION_GENERIC_SET_1_ENVIRONMENT_CONFIG = 2;

	/* Configuration saving parameter codes. */
	public static final byte
		PACKET_ID_CONFIG_PROFILE_NONE = (PARAMETER_NONE),
		PACKET_ID_CONFIG_PROFILE_SAVE = 1,
		PACKET_ID_CONFIG_RESET = 2,
		PACKET_ID_CONFIG_RESTORE_CONFIGURATION = 3,
		PACKET_ID_CONFIG_ACTIVE_MODULE_INDEX = 10,
		PACKET_ID_CONFIG_MODULE_LIST = 11;


	/* Network */
	public static final byte
		PARAMETER_ID_NETWORK_ADDRESS = 1; /* Network configuration. */

	protected static final String SAVE_CONFIG = null;

	public static final int PACKET_ID = 0;

	public static final byte ERROR_NO_ERROR						= 0,	//No error (positive acknowledge). Indicates successful completion of command or request.
							ERROR_INTERNAL_ERROR				= 1,	//System internal error during operation.
							ERROR_WRITE_ERROR					= 2,	//Non-volatile memory write error.
							ERROR_FUNCTION_NOT_IMPLEMENTED		= 3,	//Function not implemented.
							ERROR_VALUE_OUT_OF_RANGE			= 4,	//Value outside of valid range.
							ERROR_INFORMATION_CANNOT_BE_GENERATED=5,	//Requested information can’t be generated
							ERROR_COMMAND_CANNOT_BE_EXECUTED	= 6,	//Command can’t be executed.
							ERROR_INVALID_DATA_FORMAT			= 7,	//Invalid data format.
							ERROR_INVALID_VALUE					= 8,	//Invalid value, same as “Value out of range” error, but more generic. 
							ERROR_NO_MEMORY						= 9,	//Not enough memory for operation.
							ERROR_REQUESTED_ELEMENT_NOT_FOUND	= 10,	//Requested element not found.
							ERROR_TIMED_OUT						= 11;	//Timed out

	//PicoBUC Bias board
	public static final byte PARAMETER_PICOBUC_LO_SELECT = 1;

	public static final byte PARAMETER_ID_CONFIGURATION_LO_SET 					= 1,
							PARAMETER_ID_CONFIGURATION_MUTE 					= 2,
							PARAMETER_ID_CONFIGURATION_GAIN 					= 3,
							PARAMETER_ID_CONFIGURATION_ATTENUATION 				= 4,
							PARAMETER_ID_CONFIGURATION_GAIN_RANGE 				= 5,
							PARAMETER_ID_CONFIGURATION_LO_FREQUENCIES			= 7,
							PARAMETER_ID_CONFIGURATION_USER_FREQUENCY 			= 8,
							PARAMETER_ID_CONFIGURATION_USER_FREQUENCY_RANGE 	= 9,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_ENABLE		= 10,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_MODE			= 11,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_NAME			= 12,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_STATUS		= 15,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_SET_ONLINE	= 14,
							PARAMETER_ID_CONFIGURATION_SPECTRUM_INVERSION		= 20;

	/* PicoBUC production procedures */
	public static final byte PARAMETER_ID_PRODUCTION_GENERIC_SET_1_DP_INIT = 1; /* Re-init default values of RDAC */

	//ProtoPacketIds
	public static final byte PARAMETER_ID_RETRANSMIT 		= 5;

	public static final byte IRT_SLCP_PARAMETER_PROTOCOL_ADDRESS	= 3;

	//AlarmsPacketIds
	public static final byte NUMBER_OF_ALARMS 		= 1,
							ALARMS_IDs				= 2,
							ALARM_SUMMARY_STATUS	= 3,
							ALARM_CONFIG			= 4,
							ALARM_STATUS			= 5,
							ALARM_DESCRIPTION 		= 6,
							ALARM_NAME				= 7;

	/* Redundancy Controller's commands. */
	public static final byte
		PARAMETER_ID_REDUNDANCY_CONTROLLER_NONE = 0,
		PARAMETER_ID_REDUNDANCY_CONTROLLER_SWITCHOVER_MODE = 1,
		PARAMETER_ID_REDUNDANCY_CONTROLLER_STANDBY_MODE = 2,
		PARAMETER_ID_REDUNDANCY_CONTROLLER_STATUS = 3,
		PARAMETER_ID_REDUNDANCY_CONTROLLER_SWITCHOVER = 4;

	private PacketHeader header;	//irtslcp_packet_header
	private List<Payload> payloads;	//irtslcp_payload
	private final long timeout = 100;
	private int maxSize = 4;

	public PacketImp() {}

	public PacketImp(PacketImp packet) {
		set(packet.toBytes());
	}

	public byte[] toBytes() {
		return PacketThread.preparePacket(getData());
	}

	public byte[] getData() {
		byte[] d = header!=null ? header.toBytes() : null;
		if(payloads!=null)
			for(Payload b:payloads)
				d = concat(d, b.getPayloadAsBytes());
		return d;
	}

	public void set(byte[]data){
		header = new PacketHeader();
		data = header.set(data);
		setPayloads(data);
	}

	private void setPayloads(byte[] data) {

		payloads = new ArrayList<>();
		Payload p;

		while(data!=null){
			p = new Payload();
			data = p.setPayload(data);
			if(p.isSet())
				payloads.add(p);
		}

		if(payloads.size()==0)
			payloads = null;
	}

	public PacketHeader		getHeader()		{ return header;	}
	public List<Payload>	getPayloads()	{ return payloads;	}

	public void setHeader(PacketHeader header)		{ this.header = header;		}
	public void setPayloads(List<Payload> payloads)	{ this.payloads = payloads;	}

	public int size() {

		int size = 0;
		if(header!=null){
			size = PacketHeader.SIZE;
			if(payloads!=null)
				for(Payload p:payloads)
					size += ParameterHeader.SIZE + p.getParameterHeader().getSize();
		}
		
		return size;
	}

	public Payload getPayload(int index) {
		return payloads!=null && payloads.size()>index ? payloads.get(index) : null;
	}

	public Payload getPayload(byte parameter) {
		Payload pl = null;

		if (payloads != null)
			for (int i = 0; i < payloads.size(); i++)
				if (payloads.get(i).getParameterHeader().getCode() == parameter) {
					pl = payloads.get(i);
					break;
				}

		return pl;
	}

	//************************************************************************************************************
	/**
	 * @param value
	 * @param bytePosition start from 0
	 * @return one byte 
	 */
	public static byte getByte(long value, int bytePosition){
		return (byte)(bytePosition>0 ? (value >> 8*bytePosition) : value);
	}

	public static byte[] concat(byte[] s, byte[] second) {

		byte[] result = null;

		if(s==null)
			result = second;
		else if(second==null)
			result = s;
		else{
			result = Arrays.copyOf(s, s.length + second.length);
			System.arraycopy(second, 0, result, s.length, second.length);
		}

		return result;
	}

	public static byte[] concatAll(byte[] first, byte[]... rest) { 
		  int totalLength = first.length; 
		  for (byte[] array : rest) { 
		    totalLength += array.length; 
		  } 
		  byte[] result = Arrays.copyOf(first, totalLength); 
		  int offset = first.length; 
		  for (byte[] array : rest) { 
		    System.arraycopy(array, 0, result, offset, array.length); 
		    offset += array.length; 
		  } 
		  return result; 
		}

	public static long shiftAndAdd(byte[] toAdd) {
		long toShift = 0;

		if (toAdd != null)
			for (byte b : toAdd)
				toShift = shiftAndAdd(toShift, b);

		return toShift;
	}

	public static long shiftAndAdd(long toShift, byte toAdd) {
		long l = toAdd & 0xff;
		return (toShift<<8) ^ l;
	}

	public static <T> byte[] toBytes(T value) {

		if(value==null)
			return null;

		byte[] bytes = null;

		if(value instanceof Byte)
			bytes = new byte[]{(Byte) value};
		else if(value instanceof Short)
			bytes = shortToBytes((Short)value);
		else if(value instanceof Integer)
			bytes = intToBytes((Integer)value);
		else if(value instanceof Long)
			bytes = longToBytes((Long)value);

		return bytes;
	}

	public static byte[] longToBytes(long value) {
		byte[] bs = new byte[8];

		bs[7] = (byte)	value;
		bs[6] = (byte) (value>>8);
		bs[5] = (byte) (value>>16);
		bs[4] = (byte) (value>>24);
		bs[3] = (byte) (value>>32);
		bs[2] = (byte) (value>>40);
		bs[1] = (byte) (value>>48);
		bs[0] = (byte) (value>>56);

		return bs;
	}

	public static byte[] intToBytes(int value) {
		byte[] bs = new byte[4];

		bs[3] = (byte)	value;
		bs[2] = (byte) (value>>8);
		bs[1] = (byte) (value>>16);
		bs[0] = (byte) (value>>24);

		return bs;
	}

	private static byte[] shortToBytes(short value) {
		byte[] bs = new byte[2];

		bs[1] = (byte)	value;
		bs[0] = (byte) (value>>8);

		return bs;
	}

	@Override
	public int hashCode() {
		return 32 + ((header == null) ? 0 : header.getPacketId());
	}

	@Override
	public boolean equals(Object obj) {

		if (this == obj)
			return true;

		return Optional

				.ofNullable(obj)
				.filter(Packet.class::isInstance)
				.map(Packet.class::cast)
				.filter(other->{
					final Short id = Optional.ofNullable(header).map(PacketHeader::getPacketId).orElse((short) 0);
					final Short otherId = Optional.ofNullable(other.getHeader()).map(PacketHeader::getPacketId).orElse((short) 0);
					return id.equals(otherId);
				})
				.isPresent();
	}

	@Override
	public String toString() {
		return getClass().getSimpleName() + "=[\n\t"+header + ",\n\t" + payloads+"] toBytes()=" + ToHex.bytesToHex(toBytes());
	}

	@Override
	public byte[] getAcknowledg() {

		final byte[] b = new byte[3];
		final byte[] idBytes = header.packetIdAsBytes();

		b[0] = (byte) 0xFF;
		b[1] = idBytes[0];
		b[2] = idBytes[1];

		return PacketThread.preparePacket(b);
	}

	@Override
	public long getTimeout() {
		return timeout;
	}

	@Override
	public int getMaxSize() {
		return maxSize;
	}
}
