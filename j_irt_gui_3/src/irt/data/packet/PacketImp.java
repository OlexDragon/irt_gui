/*
 * IRT Management Protocol Specification.docx
 * 
 * 3. Application Layer
 * 3.1 Packet structure
 * Serial line protocol management packet consists of header and one or multiple parameters. 
 */
package irt.data.packet;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import irt.data.ToHex;

public class PacketImp implements Packet{

	public static final int NO_ERROR = 0;

	public static final byte FLAG_SEQUENCE	= 0x7E;
	public static final byte CONTROL_ESCAPE= 0x7D;

	// What to do
	public static final byte
							OPTYPE_SHOW_DEVICE = 1;
	public static final byte
							OPTYPE_CONFIG_GET_ALL			= 100,
							OPTYPE_CONFIG_SET_FREQUENCY		= 101,
							OPTYPE_CONFIG_GET_FREQUENCY		= 102,
							OPTYPE_CONFIG_SET_GAIN			= 103,
							OPTYPE_CONFIG_GET_GAIN			= 104,
							OPTYPE_CONFIG_SET_MUTE			= 105,
							OPTYPE_CONFIG_GET_MUTE			= 106,
							OPTYPE_CONFIG_SET_ATTENUATION	= 107,
							OPTYPE_CONFIG_GET_ATTENUATION	= 108,
							OPTYPE_CONFIG_GET_ATTEN_RANGE 	= 109,
							OPTYPE_CONFIG_SET_BUC_PS_ENABLE	= 110,
							OPTYPE_CONFIG_GET_BUC_PS_ENABLE	= 111,
							OPTYPE_CONFIG_GAIN_RANGE		= 112,
							OPTYPE_DAC1_VALUE_GET			= 113,
							OPTYPE_DAC2_VALUE_GET			= 114,
							OPTYPE_DAC3_VALUE_GET			= 115,
							OPTYPE_DAC4_VALUE_GET			= 116,
							OPTYPE_DAC1_VALUE_SET			= 117,
							OPTYPE_DAC2_VALUE_SET			= 118,
							OPTYPE_DAC3_VALUE_SET			= 119,
							OPTYPE_DAC4_VALUE_SET			= 120,
					
							OPTYPE_STATUS_GET_ALL			= 124,
							OPTYPE_SAVE_CONFIG				= 125,
							OPTYPE_SHOW_ALARMS				= 126,
							OPTYPE_ENVIRONMENT_CONFIGURATION= 127;

	public static final short
							OPTYPE_TEST_SET1_PLL_SET		= 10000,
							OPTYPE_DAC_VALUE_SET			= 10001,
							OPTYPE_DAC_VALUE_GET			= 10002,
							OPTYPE_PLL_REGISTER_VALUE_SET	= 10003,
							OPTYPE_VCO_SELECT_SET			= 10004,
							OPTYPE_BAND_SELECT_SET			= 10005,
							OPTYPE_CALIBRATION_ON_OFF 		= 10006;

	/* 3.2 Packet header 
	 * Packet header includes the following fields:
	 */
	public static final byte
		PACKET_TYPE_SPONTANEOUS		= 0x0,			/* Spontaneous message, generated by device. */
		PACKET_TYPE_RESPONSE		= 0x1,			/* Response, generated as response to command or status request. */
		PACKET_TYPE_REQUEST			= 0x2,			/* Status request. */
		PACKET_TYPE_COMMAND			= 0x3,			/* Command. */
		PACKET_TYPE_ACKNOWLEDGEMENT	= (byte) 0xFF;	/* Layer 2 acknowledgement. */

	/*	User interface.
	 *  Packet ID.
	 *  Packet ID represents unique identifier of “command/request – response” transaction.
	 *  Packet ID is generated on the client side and is copied to response message on the server side.
	 *   Acknowledgement message always contains ID of the received packet acknowledgement was sent on. */
	public static final byte
		IRT_SLCP_PACKET_ID_NONE	= 0,		/* Reserved for special use. */
		GROUP_ID_ALARM			= 1,		/* Alarm: message content is product specific. */
		GROUP_ID_CONFIGURATION	= 2,		/* Configuration: content is product specific. */
		GROUP_ID_FILETRANSFER	= 3,		/* File transfer: software upgrade command (optional). */
		GROUP_ID_MEASUREMENT	= 4,		/* Measurement: device status, content is product specific. */
		GROUP_ID_RESET			= 5,		/* Device reset: generic command. */
		GROUP_ID_DEVICE_INFO	= 8,		/* Device information: generic command. */
		GROUP_ID_CONFIG_PROFILE	= 9,		/* Save configuration: generic command. */
		GROUP_ID_DEVICE_DEBAG	= 61,		/* Device Debug. */

	/* Protocol */
		GROUP_ID_PROTOCOL = 10, /* Packet protocol parameters configuration and monitoring. */

	/* Network */
		GROUP_ID_NETWORK = 11, /* Network configuration. */

	/* backwards compatibility - to be deleted */
		GROUP_ID_PRODUCTION_GENERIC_SET_1 = 100,
		GROUP_ID_DEVELOPER_GENERIC_SET_1 = 120;
	/* Parameter general types definition. */
	public static final byte
		PARAMETER_NONE		= 0,
		PARAMETER_ALL		= (byte) 255;

	/* Measurement codes. */
	public static final byte
			PARAMETER_MEASUREMENT_INPUT_POWER	= 1,
			PARAMETER_MEASUREMENT_OUTPUT_POWER	= 2,
			PARAMETER_MEASUREMENT_STATUS		= 4,
			PARAMETER_MEASUREMENT_WGS_POSITION	= 4,
			PARAMETER_MEASUREMENT_LNB1_STATUS	= 5,
			PARAMETER_MEASUREMENT_LNB2_STATUS	= 6,
			IRT_SLCP_PARAMETER_MEASUREMENT_PICOBUC_ALL = PARAMETER_ALL; /* Read all available measurements. */

	public static final byte
		PARAMETER_MEASUREMENT_FCM_NONE = PARAMETER_NONE,
		PARAMETER_MEASUREMENT_FCM_SUMMARY_ALARM		= 1,	//Flags
		PARAMETER_MEASUREMENT_FCM_STATUS			= 2,
		PARAMETER_MEASUREMENT_TEMPERATURE			= 3,
		PARAMETER_MEASUREMENT_FCM_INPUT_POWER		= 4,
		PARAMETER_MEASUREMENT_FCM_OUTPUT_POWER		= 5,
		PARAMETER_MEASUREMENT_FCM_MON_5V5			= 6,
		PARAMETER_MEASUREMENT_FCM_MON_13V2_POS		= 7,
		PARAMETER_MEASUREMENT_FCM_MON_13V2_NEG		= 8,
		PARAMETER_MEASUREMENT_FCM_CURRENT			= 9,
		PARAMETER_MEASUREMENT_FCM_TEMPERATURE_CPU	= 10,
		PARAMETER_MEASUREMENT_FCM_ALL = PARAMETER_ALL;	/* Read all available measurements. */

	/*Device Debug - IRT_SLCP_PACKET_ID_DEVICE_DEBAG*/
	public static final byte
	PARAMETER_DEVICE_DEBAG_INFO 		= 1,		/* device information: parts, firmware and etc. */
	PARAMETER_DEVICE_DEBAG_DUMP 		= 2,		/* dump of registers for specified device index */
	PARAMETER_DEVICE_DEBAG_READ_WRITE 	= 3,		/* registers read/write operations */
	PARAMETER_DEVICE_DEBAG_INDEX 		= 4,		/* device index information print */
	PARAMETER_DEVICE_DEBAG_CALIBRATION_MODE = 5,	/* calibration mode */
	PARAMETER_DEVICE_DEBUG_ENVIRONMENT_IO = 10;	/* operations with environment variables */

	/* Configuration codes. */
	public static final byte
		PARAMETER_CONFIG_FCM_NONE = (PARAMETER_NONE),
		PARAMETER_CONFIG_FCM_GAIN										= 1,
		PARAMETER_CONFIG_FCM_ATTENUATION								= 2,
		PARAMETER_CONFIG_FCM_FREQUENCY									= 3,
		PARAMETER_CONFIG_FCM_FREQUENCY_RANGE							= 4,
		PARAMETER_CONFIG_FCM_GAIN_RANGE									= 5,
		PARAMETER_CONFIG_ATTENUATION_RANGE								= 6,
		PARAMETER_CONFIG_FCM_MUTE_CONTROL								= 7,
		PARAMETER_CONFIG_LNB_POWER										= 8,
		PARAMETER_CONFIG_FCM_FLAGS 										= 9,
		PARAMETER_CONFIG_FCM_GAIN_OFFSET								= 10,
		PARAMETER_CONFIG_FCM_ALC_ENABLED								= 12,
		PARAMETER_CONFIG_FCM_ALC_LEVEL									= 13,
		PARAMETER_CONFIG_FCM_ALC_RANGE									= 14,
		PARAMETER_CONFIG_DLRS_WGS_SWITCHOVER							= 14,
		PARAMETER_CONFIG_FCM_ALC_OVERDRIVE_PROTECTION_ENABLED			= 15,
		PARAMETER_CONFIG_FCM_ALC_OVERDRIVE_PROTECTION_THRESHOLD			= 16,
		PARAMETER_CONFIG_FCM_ALC_OVERDRIVE_PROTECTION_THRESHOLD_RANGE	= 17,
		PARAMETER_CONFIG_FCM_LNB_REFERENCE_CONTROL						= 21,
		PARAMETER_CONFIG_BUC_APC_ENABLE                					= 110,     /* APC enable */
		PARAMETER_CONFIG_BUC_APC_LEVEL		          					= 111,     /* APC target power level */
		PARAMETER_CONFIG_BUC_APC_RANGE        		  					= 112,     /* APC target power range */

		PARAMETER_CONFIG_FCM_ALL = PARAMETER_ALL;		/* Read all available parameters. */

	/* Test. */
	public static final byte
		IRT_SLCP_PARAMETER_DEVELOPER_GENERIC_SET_1_DAC_CONFIG = 1;

	public static final byte
	PARAMETER_PRODUCTION_GENERIC_SET_1_CALIBRATION_MODE_CONFIG = 1,
	PARAMETER_PRODUCTION_GENERIC_SET_1_ENVIRONMENT_CONFIG = 2;

	/* Configuration saving parameter codes. */
	public static final byte
		PACKET_ID_CONFIG_PROFILE_NONE = (PARAMETER_NONE),
		PACKET_ID_CONFIG_PROFILE_SAVE = 1;


	/* Network */
	public static final byte
		PARAMETER_ID_NETWORK_ADDRESS = 1; /* Network configuration. */

	protected static final String SAVE_CONFIG = null;

	public static final int PACKET_ID = 0;

	public static final byte ERROR_NO_ERROR						= 0,	//No error (positive acknowledge). Indicates successful completion of command or request.
							ERROR_INTERNAL_ERROR				= 1,	//System internal error during operation.
							ERROR_WRITE_ERROR					= 2,	//Non-volatile memory write error.
							ERROR_FUNCTION_NOT_IMPLEMENTED		= 3,	//Function not implemented.
							ERROR_VALUE_OUT_OF_RANGE			= 4,	//Value outside of valid range.
							ERROR_INFORMATION_CANNOT_BE_GENERATED=5,	//Requested information can’t be generated
							ERROR_COMMAND_CANNOT_BE_EXECUTED	= 6,	//Command can’t be executed.
							ERROR_INVALID_DATA_FORMAT			= 7,	//Invalid data format.
							ERROR_INVALID_VALUE					= 8,	//Invalid value, same as “Value out of range” error, but more generic. 
							ERROR_NO_MEMORY						= 9,	//Not enough memory for operation.
							ERROR_REQUESTED_ELEMENT_NOT_FOUND	= 10,	//Requested element not found.
							ERROR_TIMED_OUT						= 11;	//Timed out

	//PicoBUC Bias board
	public static final byte IRT_SLCP_PARAMETER_PICOBUC_LO_SELECT = 1;

	public static final byte PARAMETER_ID_CONFIGURATION_LO_SET 					= 1,
							PARAMETER_ID_CONFIGURATION_MUTE 					= 2,
							PARAMETER_ID_CONFIGURATION_GAIN 					= 3,
							PARAMETER_ID_CONFIGURATION_ATTENUATION 				= 4,
							PARAMETER_ID_CONFIGURATION_GAIN_RANGE 				= 5,
							PARAMETER_ID_CONFIGURATION_LO_FREQUENCIES			= 7,
							PARAMETER_ID_CONFIGURATION_USER_FREQUENCY 			= 8,
							PARAMETER_ID_CONFIGURATION_USER_FREQUENCY_RANGE 	= 9,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_ENABLE		= 10,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_MODE			= 11,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_NAME			= 12,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_STATUS		= 15,
							PARAMETER_ID_CONFIGURATION_REDUNDANCY_SET_ONLINE	= 14,
							PARAMETER_ID_CONFIGURATION_SPECTRUM_INVERSION		= 20;

	/* PicoBUC production procedures */
	public static final byte PARAMETER_ID_PRODUCTION_GENERIC_SET_1_DP_INIT = 1; /* Re-init default values of RDAC */

	public static final byte IRT_SLCP_PARAMETER_PROTOCOL_ADDRESS	= 3;

	//Alarms
	public static final byte NUMBER_OF_ALARMS 		= 1,
							ALARMS_IDs				= 2,
							ALARM_SUMMARY_STATUS	= 3,
							ALARM_CONFIG			= 4,
							ALARM_STATUS			= 5,
							ALARM_DESCRIPTION 		= 6,
							ALARM_NAME				= 7;

	private PacketHeader header;	//irtslcp_packet_header
	private List<Payload> payloads;	//irtslcp_payload

	public PacketImp() {}

	public PacketImp(PacketImp packet) {
		set(packet.toBytes());
	}

	public byte[] toBytes() {
		byte[] d = header!=null ? header.toBytes() : null;
		if(payloads!=null)
			for(Payload b:payloads)
				d = concat(d, b.getPayloadAsBytes());
		return d;
	}

	public void set(byte[]data){
		header = new PacketHeader();
		data = header.set(data);
		setPayloads(data);
	}

	private void setPayloads(byte[] data) {

		payloads = new ArrayList<>();
		Payload p;

		while(data!=null){
			p = new Payload();
			data = p.setPayload(data);
			if(p.isSet())
				payloads.add(p);
		}

		if(payloads.size()==0)
			payloads = null;
	}

	public PacketHeader		getHeader()		{ return header;	}
	public List<Payload>	getPayloads()	{ return payloads;	}

	public void setHeader(PacketHeader header)		{ this.header = header;		}
	public void setPayloads(List<Payload> payloads)	{ this.payloads = payloads;	}

	public int size() {

		int size = 0;
		if(header!=null){
			size = PacketHeader.SIZE;
			if(payloads!=null)
				for(Payload p:payloads)
					size += ParameterHeader.SIZE + p.getParameterHeader().getSize();
		}
		
		return size;
	}

	public static PacketImp creatPacket(int optype) {
		PacketImp packet = new PacketImp();

		switch(optype){
		case OPTYPE_SHOW_DEVICE:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,
											GROUP_ID_DEVICE_INFO,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_ALL,0,0});
			break;
		case OPTYPE_STATUS_GET_ALL:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,
											GROUP_ID_MEASUREMENT,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_ALL,0,0});
			break;
		case OPTYPE_CONFIG_GET_MUTE:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,
											GROUP_ID_CONFIGURATION,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_CONFIG_FCM_MUTE_CONTROL,0,0});
			break;
		case OPTYPE_CONFIG_SET_MUTE:
			packet.set(new byte[]{	PACKET_TYPE_COMMAND,
											GROUP_ID_CONFIGURATION,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_CONFIG_FCM_MUTE_CONTROL,0,0});
			break;
		case OPTYPE_CONFIG_GET_FREQUENCY:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,
											GROUP_ID_CONFIGURATION,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_CONFIG_FCM_FREQUENCY,0,0});
			break;
		case OPTYPE_CONFIG_SET_FREQUENCY:
			packet.set(new byte[]{	PACKET_TYPE_COMMAND,
											GROUP_ID_CONFIGURATION,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_CONFIG_FCM_FREQUENCY,0,0});
			break;
		case OPTYPE_CONFIG_GET_ATTENUATION:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,
											GROUP_ID_CONFIGURATION,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_CONFIG_FCM_ATTENUATION,0,0});
			break;
		case OPTYPE_CONFIG_GET_ATTEN_RANGE:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,
											GROUP_ID_CONFIGURATION,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_CONFIG_ATTENUATION_RANGE,0,0});
			break;
		case OPTYPE_CONFIG_SET_ATTENUATION:
			packet.set(new byte[]{	PACKET_TYPE_COMMAND,
											GROUP_ID_CONFIGURATION,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_CONFIG_FCM_ATTENUATION,0,0});
			break;
		case OPTYPE_CONFIG_SET_GAIN:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,
											GROUP_ID_DEVELOPER_GENERIC_SET_1,
											PACKET_TYPE_SPONTANEOUS,
											IRT_SLCP_PARAMETER_DEVELOPER_GENERIC_SET_1_DAC_CONFIG,0,0});
			break;
		case OPTYPE_CONFIG_GAIN_RANGE:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,
											GROUP_ID_CONFIGURATION,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_CONFIG_FCM_GAIN_RANGE ,0,0});
			break;
		case OPTYPE_SAVE_CONFIG:
			packet.set(new byte[]{	PACKET_TYPE_COMMAND,
											GROUP_ID_CONFIG_PROFILE,
											PACKET_TYPE_SPONTANEOUS,
											PACKET_ID_CONFIG_PROFILE_SAVE,0,0});
			break;
		case OPTYPE_ENVIRONMENT_CONFIGURATION:
			packet.set(new byte[]{	PACKET_TYPE_COMMAND,
											GROUP_ID_PRODUCTION_GENERIC_SET_1,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_PRODUCTION_GENERIC_SET_1_ENVIRONMENT_CONFIG,0,0});
			break;
		case OPTYPE_CALIBRATION_ON_OFF:
			packet.set(new byte[]{	PACKET_TYPE_COMMAND,
											GROUP_ID_PRODUCTION_GENERIC_SET_1,
											PACKET_TYPE_SPONTANEOUS,
											PARAMETER_PRODUCTION_GENERIC_SET_1_CALIBRATION_MODE_CONFIG,0,0});
			break;
		case OPTYPE_DAC_VALUE_GET:
			packet.set(new byte[]{	PACKET_TYPE_REQUEST,//TODO
											GROUP_ID_DEVELOPER_GENERIC_SET_1,
											PACKET_TYPE_SPONTANEOUS,
											IRT_SLCP_PARAMETER_DEVELOPER_GENERIC_SET_1_DAC_CONFIG,0,0});
			break;
		case OPTYPE_DAC_VALUE_SET:
			packet.set(new byte[]{	PACKET_TYPE_COMMAND,
											GROUP_ID_DEVELOPER_GENERIC_SET_1,
											PACKET_TYPE_SPONTANEOUS,
											IRT_SLCP_PARAMETER_DEVELOPER_GENERIC_SET_1_DAC_CONFIG,0,0});
		}
		return packet;
	}

	public Payload getPayload(int index) {
		return payloads!=null && payloads.size()>index ? payloads.get(index) : null;
	}

	public Payload getPayload(byte parameter) {
		Payload pl = null;

		if (payloads != null)
			for (int i = 0; i < payloads.size(); i++)
				if (payloads.get(i).getParameterHeader().getCode() == parameter) {
					pl = payloads.get(i);
					break;
				}

		return pl;
	}

	//************************************************************************************************************
	/**
	 * @param value
	 * @param bytePosition start from 0
	 * @return one byte 
	 */
	public static byte getByte(long value, int bytePosition){
		return (byte)(bytePosition>0 ? (value >> 8*bytePosition) : value);
	}

	public static byte[] concat(byte[] s, byte[] second) {

		byte[] result = null;

		if(s==null)
			result = second;
		else if(second==null)
			result = s;
		else{
			result = Arrays.copyOf(s, s.length + second.length);
			System.arraycopy(second, 0, result, s.length, second.length);
		}

		return result;
	}

	public static byte[] concatAll(byte[] first, byte[]... rest) { 
		  int totalLength = first.length; 
		  for (byte[] array : rest) { 
		    totalLength += array.length; 
		  } 
		  byte[] result = Arrays.copyOf(first, totalLength); 
		  int offset = first.length; 
		  for (byte[] array : rest) { 
		    System.arraycopy(array, 0, result, offset, array.length); 
		    offset += array.length; 
		  } 
		  return result; 
		}

	public static long shiftAndAdd(byte[] toAdd) {
		long toShift = 0;

		if (toAdd != null)
			for (byte b : toAdd)
				toShift = shiftAndAdd(toShift, b);

		return toShift;
	}

	public static long shiftAndAdd(long toShift, byte toAdd) {
		long l = toAdd & 0xff;
		return (toShift<<8) ^ l;
	}

	public static <T> byte[] toBytes(T value) {
		byte[] bytes = null;

		if(value!=null){
			if(value instanceof Byte)
				bytes = new byte[]{(Byte) value};
			else if(value instanceof Short)
				bytes = shortToBytes((Short)value);
			else if(value instanceof Integer)
				bytes = intToBytes((Integer)value);
			else if(value instanceof Long)
				bytes = longToBytes((Long)value);
		}

		return bytes;
	}

	private static byte[] longToBytes(long value) {
		byte[] bs = new byte[8];

		bs[7] = (byte)	value;
		bs[6] = (byte) (value>>8);
		bs[5] = (byte) (value>>16);
		bs[4] = (byte) (value>>24);
		bs[3] = (byte) (value>>32);
		bs[2] = (byte) (value>>40);
		bs[1] = (byte) (value>>48);
		bs[0] = (byte) (value>>56);

		return bs;
	}

	private static byte[] intToBytes(int value) {
		byte[] bs = new byte[4];

		bs[3] = (byte)	value;
		bs[2] = (byte) (value>>8);
		bs[1] = (byte) (value>>16);
		bs[0] = (byte) (value>>24);

		return bs;
	}

	private static byte[] shortToBytes(short value) {
		byte[] bs = new byte[2];

		bs[1] = (byte)	value;
		bs[0] = (byte) (value>>8);

		return bs;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = prime + ((header == null) ? 0 : header.getPacketId());
		result = prime * result + ((payloads == null) ? 0 : payloads.get(0).getParameterHeader().getCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof Packet))
			return false;
		Packet other = (Packet) obj;
		if (header == null) {
			if (other.getHeader() != null)
				return false;
		} else if (header.getPacketId()!=other.getHeader().getPacketId())
			return false;
		if (payloads == null) {
			if (other.getPayloads() != null)
				return false;
		} else if (payloads.get(0).getParameterHeader().getCode()!=(other.getPayloads().get(0).getParameterHeader().getCode()))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "Packet=[\n\t"+header + ",\n\t" + payloads+"] toBytes()=" + ToHex.bytesToHex(toBytes());
	}
}
